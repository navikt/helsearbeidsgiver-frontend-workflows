name: dependabot-delayed-merge

on:
  workflow_call:
    inputs:
      only-actor:
        description: Only merge PRs authored by this actor (e.g., dependabot[bot])
        required: false
        default: dependabot[bot]
        type: string
      label-name:
        description: Label that marks PRs as eligible for delayed merge
        required: false
        default: automerge:delayed
        type: string
      days-delay:
        description: Number of days to wait before merging
        required: false
        default: 5
        type: number
      merge-method:
        description: Merge method (merge, squash, rebase)
        required: false
        default: squash
        type: string
      allow-draft:
        description: Merge drafts if true
        required: false
        default: false
        type: boolean
      require-clean-mergeable-state:
        description: Require mergeable_state to be clean
        required: false
        default: true
        type: boolean
      dry-run:
        description: Log instead of merging
        required: false
        default: false
        type: boolean
    secrets:
      token:
        description: Token to use for API calls; defaults to GITHUB_TOKEN if omitted
        required: false

permissions:
  contents: write
  pull-requests: write

jobs:
  merge:
    runs-on: ubuntu-latest
    steps:
      - name: Merge eligible PRs
        uses: actions/github-script@v7.0.1
        env:
          ONLY_ACTOR: ${{ inputs['only-actor'] }}
          LABEL_NAME: ${{ inputs['label-name'] }}
          DAYS_DELAY: ${{ inputs['days-delay'] }}
          MERGE_METHOD: ${{ inputs['merge-method'] }}
          ALLOW_DRAFT: ${{ inputs['allow-draft'] }}
          REQUIRE_CLEAN: ${{ inputs['require-clean-mergeable-state'] }}
          DRY_RUN: ${{ inputs['dry-run'] }}
        with:
          github-token: ${{ secrets.token || secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const onlyActor = process.env.ONLY_ACTOR || 'dependabot[bot]';
            const label = process.env.LABEL_NAME || 'automerge:delayed';
            const daysDelay = Number(process.env.DAYS_DELAY || 5);
            const cutoffMs = daysDelay * 24 * 60 * 60 * 1000;
            const now = Date.now();
            const allowDraft = process.env.ALLOW_DRAFT === 'true';
            const requireClean = process.env.REQUIRE_CLEAN === 'true';
            const dryRun = process.env.DRY_RUN === 'true';
            const mergeMethod = (process.env.MERGE_METHOD || 'squash');

            const sleep = (ms) => new Promise(r => setTimeout(r, ms));

            async function getPR(number) {
              const { data } = await github.rest.pulls.get({ owner, repo, pull_number: number });
              return data;
            }

            async function waitForMergeability(number, maxTries = 8, baseDelayMs = 500) {
              let last = await getPR(number);
              for (let i = 0; i < maxTries; i++) {
                const ready = last.mergeable !== null && last.mergeable_state !== 'unknown';
                core.info(`#${number} mergeability check ${i + 1}/${maxTries}: mergeable=${last.mergeable}, state=${last.mergeable_state}`);
                if (ready) return last;
                await sleep(Math.min(baseDelayMs * Math.pow(2, i), 8000));
                last = await getPR(number);
              }
              return last;
            }

            async function tryUpdateBranch(pr) {
              // Only works for same-repo branches (not forks) and when "Update branch" is allowed
              const sameRepo = pr.head?.repo?.id && pr.base?.repo?.id && pr.head.repo.id === pr.base.repo.id;
              if (!sameRepo) {
                core.info(`#${pr.number} cannot update-branch (fork or missing repo info).`);
                return false;
              }
              try {
                core.info(`#${pr.number} attempting update-branch to poke mergeability...`);
                await github.request('PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch', {
                  owner, repo, pull_number: pr.number,
                  // expected_head_sha optional; omit to avoid 412 conflicts
                });
                return true;
              } catch (e) {
                core.info(`#${pr.number} update-branch not possible: ${e.status || ''} ${e.message}`);
                return false;
              }
            }

            async function maybeAskDependabotToRebase(pr) {
              if (pr.user?.login !== 'dependabot[bot]') return false;
              const marker = '<!-- automerge:delayed:poke-mergeability -->';
              const comments = await github.paginate(github.rest.issues.listComments, {
                owner, repo, issue_number: pr.number, per_page: 100
              });
              if (comments.some(c => typeof c.body === 'string' && c.body.includes(marker))) {
                core.info(`#${pr.number} rebase comment already posted.`);
                return false;
              }
              try {
                core.info(`#${pr.number} asking Dependabot to rebase...`);
                await github.rest.issues.createComment({
                  owner, repo, issue_number: pr.number,
                  body: `${marker}\n@dependabot rebase`
                });
                return true;
              } catch (e) {
                core.info(`#${pr.number} could not comment to dependabot: ${e.message}`);
                return false;
              }
            }

            core.info(`Scanning PRs in ${owner}/${repo}, label=${label}, delayDays=${daysDelay}, onlyActor=${onlyActor}`);

            const prs = await github.paginate(github.rest.pulls.list, { owner, repo, state: 'open', per_page: 100 });
            for (const pr of prs) {
              const reasons = [];
              if (onlyActor && pr.user?.login !== onlyActor) reasons.push(`actor!=${onlyActor}`);
              const hasLabel = !!pr.labels?.some(l => l.name === label);
              if (!hasLabel) reasons.push(`missing label ${label}`);
              if (pr.draft && !allowDraft) reasons.push('draft');
              if (now - new Date(pr.created_at).getTime() < cutoffMs) reasons.push('not old enough');

              if (reasons.length) {
                core.info(`#${pr.number} skipped: ${reasons.join(', ')}`);
                continue;
              }

              // Poll for mergeability first
              let full = await waitForMergeability(pr.number);

              // If still unknown, try to poke GitHub to recompute
              if (full.mergeable_state === 'unknown' || full.mergeable === null) {
                const pokedByUpdate = await tryUpdateBranch(full);
                const pokedByDependabot = await maybeAskDependabotToRebase(full);
                if (pokedByUpdate || pokedByDependabot) {
                  // Give it some time and check again a few times
                  for (let i = 0; i < 5; i++) {
                    await sleep(2000 * (i + 1));
                    full = await getPR(pr.number);
                    core.info(`#${pr.number} post-poke state try ${i + 1}: mergeable=${full.mergeable}, state=${full.mergeable_state}`);
                    if (full.mergeable !== null && full.mergeable_state !== 'unknown') break;
                  }
                }
              }

              if (full.mergeable_state === 'unknown' || full.mergeable === null) {
                core.info(`#${pr.number} skipped: mergeable_state still unknown after retries.`);
                continue;
              }

              if (requireClean && full.mergeable_state !== 'clean') {
                core.info(`#${pr.number} skipped: mergeable_state=${full.mergeable_state}`);
                continue;
              }

              try {
                if (dryRun) {
                  core.info(`[dry-run] Would merge #${pr.number} with method=${mergeMethod}`);
                } else {
                  await github.rest.pulls.merge({ owner, repo, pull_number: pr.number, merge_method: mergeMethod });
                  core.info(`Merged #${pr.number}`);
                }
              } catch (e) {
                core.warning(`Could not merge #${pr.number}: ${e.message}`);
              }
            }
